<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Streaming Bridge - Monitoring Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .status-bar {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        
        .status-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 15px;
            border-radius: 4px;
            flex: 1;
        }
        
        .status-item label {
            display: block;
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .status-item .value {
            font-size: 24px;
            font-weight: bold;
        }
        
        .status-item.active .value {
            color: #2ecc71;
        }
        
        .status-item.inactive .value {
            color: #95a5a6;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .card h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .call-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .call-item {
            padding: 12px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .call-item:last-child {
            border-bottom: none;
        }
        
        .call-item.active {
            background: #e8f5e9;
        }
        
        .call-info {
            flex: 1;
        }
        
        .call-id {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .call-numbers {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        
        .call-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .status-active {
            background: #2ecc71;
            color: white;
        }
        
        .status-completed {
            background: #95a5a6;
            color: white;
        }
        
        .status-initiating {
            background: #f39c12;
            color: white;
        }
        
        .audio-stream {
            margin-top: 20px;
        }
        
        .stream-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #3498db;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            flex: 1;
        }
        
        .connection-status {
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }
        
        .connection-status.connected {
            background: #2ecc71;
            color: white;
        }
        
        .connection-status.disconnected {
            background: #e74c3c;
            color: white;
        }
        
        .audio-visualizer {
            background: #2c3e50;
            border-radius: 4px;
            padding: 20px;
            margin-top: 15px;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: #3498db;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Audio Streaming Bridge - Monitoring Dashboard</h1>
            <div class="status-bar">
                <div class="status-item" id="ws-status">
                    <label>WebSocket Status</label>
                    <div class="value">Disconnected</div>
                </div>
                <div class="status-item" id="active-calls">
                    <label>Active Calls</label>
                    <div class="value">0</div>
                </div>
                <div class="status-item" id="completed-calls">
                    <label>Completed Calls</label>
                    <div class="value">0</div>
                </div>
                <div class="status-item" id="error-calls">
                    <label>Error Calls</label>
                    <div class="value">0</div>
                </div>
                <div class="status-item" id="total-calls">
                    <label>Total Calls</label>
                    <div class="value">0</div>
                </div>
            </div>
        </header>
        
        <div class="dashboard">
            <div class="card">
                <h2>Active Call Streams</h2>
                <div style="margin-bottom: 10px; font-size: 12px; color: #666;">
                    ðŸ’¡ Click any active call below to connect automatically, or enter Call ID manually
                </div>
                <div class="audio-stream">
                    <div class="stream-controls">
                        <input type="text" id="call-id-input" placeholder="Enter Call ID or click a call above">
                        <button id="connect-btn">Connect</button>
                        <button id="disconnect-btn" disabled>Disconnect</button>
                    </div>
                    <div class="connection-status disconnected" id="stream-status">
                        Not Connected
                    </div>
                    <div class="audio-visualizer" id="audio-visualizer">
                        No audio stream active
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-value" id="chunks-received">0</div>
                            <div class="stat-label">Chunks Received</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="bytes-received">0</div>
                            <div class="stat-label">Bytes Received</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="stream-latency">0ms</div>
                            <div class="stat-label">Latency</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>Recent Calls</h2>
                <div class="call-list" id="call-list">
                    <div style="padding: 20px; text-align: center; color: #999;">
                        Loading calls...
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = window.location.origin;
        let ws = null;
        let chunksReceived = 0;
        let bytesReceived = 0;
        let callList = [];
        let currentConnectedCallId = null;
        let autoConnectEnabled = true; // Auto-connect to active calls
        let heartbeatInterval = null;
        let isConnecting = false; // Flag to prevent multiple simultaneous connections
        let hasAutoConnected = false; // Flag to prevent auto-connect from running multiple times
        
        // Connect to WebSocket stream
        function connectToStream() {
            const callId = document.getElementById('call-id-input').value.trim();
            if (!callId) {
                alert('Please enter a Call ID');
                return;
            }
            
            // Prevent multiple simultaneous connection attempts
            if (isConnecting) {
                console.log('Already connecting, skipping...');
                return;
            }
            
            // If already connected to this call, don't reconnect
            if (currentConnectedCallId === callId && ws && ws.readyState === WebSocket.OPEN) {
                console.log('Already connected to this call');
                return;
            }
            
            isConnecting = true;
            console.log('Connecting to WebSocket for call:', callId);
            disconnectStream(false); // Don't trigger auto-connect
            
            // Use secure WebSocket when dashboard is loaded over HTTPS (e.g. via ngrok)
            const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            const wsUrl = `${wsProtocol}://${window.location.host}/ws/audio/${callId}`;
            console.log('WebSocket URL:', wsUrl);
            
            try {
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    isConnecting = false;
                    console.log('WebSocket connected successfully to:', callId);
                    document.getElementById('stream-status').textContent = `Connected to ${callId}`;
                    document.getElementById('stream-status').className = 'connection-status connected';
                    document.getElementById('connect-btn').disabled = true;
                    document.getElementById('disconnect-btn').disabled = false;
                    document.getElementById('call-id-input').disabled = true;
                    const wsStatus = document.getElementById('ws-status');
                    wsStatus.querySelector('.value').textContent = 'Connected';
                    wsStatus.classList.add('active');
                    currentConnectedCallId = callId;
                    renderCallList(false); // Update UI to show connected call, don't auto-connect
                    
                    // Start heartbeat
                    if (heartbeatInterval) {
                        clearInterval(heartbeatInterval);
                    }
                    heartbeatInterval = setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'ping' }));
                        }
                    }, 30000);
                };
                
                ws.onmessage = (event) => {
                    if (event.data instanceof Blob) {
                        // Binary audio data
                        chunksReceived++;
                        bytesReceived += event.data.size;
                        updateStats();
                        visualizeAudio(event.data);
                    } else {
                        // JSON metadata
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'audio_chunk') {
                                document.getElementById('audio-visualizer').textContent = 
                                    `Receiving audio: ${data.data_size} bytes`;

                                // Update simple end-to-end latency metric if timestamp is present
                                if (data.timestamp) {
                                    const sent = Date.parse(data.timestamp);
                                    if (!Number.isNaN(sent)) {
                                        const now = Date.now();
                                        const latencyMs = Math.max(0, now - sent);
                                        document.getElementById('stream-latency').textContent = `${latencyMs}ms`;
                                    }
                                }
                            } else if (data.type === 'pong') {
                                // Heartbeat response
                                console.log('Received pong from server');
                            }
                        } catch (e) {
                            console.error('Error parsing message:', e);
                        }
                    }
                };
                
                ws.onerror = (error) => {
                    isConnecting = false;
                    console.error('WebSocket error:', error);
                    console.error('WebSocket readyState:', ws ? ws.readyState : 'null');
                    document.getElementById('stream-status').textContent = 'Connection Error - Check console';
                    document.getElementById('stream-status').className = 'connection-status disconnected';
                };
                
                ws.onclose = (event) => {
                    isConnecting = false;
                    console.log('WebSocket closed:', event.code, event.reason);
                    document.getElementById('stream-status').textContent = 'Disconnected';
                    document.getElementById('stream-status').className = 'connection-status disconnected';
                    document.getElementById('connect-btn').disabled = false;
                    document.getElementById('disconnect-btn').disabled = true;
                    document.getElementById('call-id-input').disabled = false;
                    const wsStatus = document.getElementById('ws-status');
                    wsStatus.querySelector('.value').textContent = 'Disconnected';
                    wsStatus.classList.remove('active');
                    currentConnectedCallId = null;
                    if (heartbeatInterval) {
                        clearInterval(heartbeatInterval);
                        heartbeatInterval = null;
                    }
                    renderCallList(false); // Update UI to remove connected indicator, don't auto-connect
                };
            } catch (error) {
                isConnecting = false;
                console.error('Error creating WebSocket:', error);
                alert('Failed to create WebSocket connection: ' + error.message);
                document.getElementById('stream-status').textContent = 'Connection Failed';
                document.getElementById('stream-status').className = 'connection-status disconnected';
            }
        }
        
        function disconnectStream(shouldAutoConnect = true) {
            if (ws) {
                ws.close();
                ws = null;
            }
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            chunksReceived = 0;
            bytesReceived = 0;
            currentConnectedCallId = null;
            isConnecting = false;
            updateStats();
            renderCallList(shouldAutoConnect); // Update UI, optionally auto-connect
        }
        
        function updateStats() {
            document.getElementById('chunks-received').textContent = chunksReceived;
            document.getElementById('bytes-received').textContent = formatBytes(bytesReceived);
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        function visualizeAudio(audioData) {
            // Simple visualization - in production, use Web Audio API for waveform
            const visualizer = document.getElementById('audio-visualizer');
            const size = audioData.size;
            visualizer.textContent = `Audio chunk: ${size} bytes`;
        }
        
        // Load call history
        async function loadCallHistory() {
            try {
                const response = await fetch(`${API_BASE}/api/calls?limit=50`);
                callList = await response.json();
                // Only auto-connect on the first load, not on every refresh
                const isFirstLoad = !hasAutoConnected && !currentConnectedCallId && !isConnecting;
                renderCallList(isFirstLoad);
                updateCallStats();
            } catch (error) {
                console.error('Error loading call history:', error);
            }
        }
        
        function renderCallList(shouldAutoConnect = false) {
            const listElement = document.getElementById('call-list');
            if (callList.length === 0) {
                listElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">No calls found</div>';
                return;
            }
            
            listElement.innerHTML = callList.map(call => {
                const statusClass = `status-${call.status}`;
                const isActive = call.status === 'active';
                const isConnected = currentConnectedCallId === call.call_id;
                return `
                    <div class="call-item ${isActive ? 'active' : ''} ${isConnected ? 'connected' : ''}" 
                         data-call-id="${call.call_id}"
                         style="cursor: pointer; ${isConnected ? 'background: #e8f5e9;' : ''}">
                        <div class="call-info">
                            <div class="call-id">${call.call_id} ${isConnected ? 'ðŸ”Š' : ''}</div>
                            <div class="call-numbers">
                                ${call.caller_number || 'N/A'} â†’ ${call.callee_number || 'N/A'}
                                ${call.duration ? ` (${call.duration}s)` : ''}
                            </div>
                        </div>
                        <div class="call-status ${statusClass}">${call.status}</div>
                    </div>
                `;
            }).join('');
            
            // Auto-connect to first active call only if:
            // 1. Auto-connect is enabled
            // 2. Not already connected
            // 3. Not currently connecting
            // 4. shouldAutoConnect is true (only on initial load or manual refresh)
            // 5. Hasn't auto-connected before (prevent infinite loops)
            if (shouldAutoConnect && autoConnectEnabled && !currentConnectedCallId && !isConnecting && !hasAutoConnected) {
                const firstActiveCall = callList.find(c => c.status === 'active');
                if (firstActiveCall) {
                    hasAutoConnected = true; // Mark as auto-connected to prevent loops
                    console.log('Auto-connecting to first active call:', firstActiveCall.call_id);
                    connectToCall(firstActiveCall.call_id);
                }
            }
        }
        
        function connectToCall(callId) {
            document.getElementById('call-id-input').value = callId;
            connectToStream();
            // currentConnectedCallId will be set in ws.onopen when connection succeeds
        }
        
        function updateCallStats() {
            const activeCalls = callList.filter(c => c.status === 'active').length;
            const completedCalls = callList.filter(c => c.status === 'completed').length;
            const errorCalls = callList.filter(c => c.status === 'failed').length;
            document.getElementById('active-calls').querySelector('.value').textContent = activeCalls;
            document.getElementById('completed-calls').querySelector('.value').textContent = completedCalls;
            document.getElementById('error-calls').querySelector('.value').textContent = errorCalls;
            document.getElementById('total-calls').querySelector('.value').textContent = callList.length;
        }
        
        // Initialize button event listeners
        function initializeEventListeners() {
            const connectBtn = document.getElementById('connect-btn');
            const disconnectBtn = document.getElementById('disconnect-btn');
            const callIdInput = document.getElementById('call-id-input');
            const callListElement = document.getElementById('call-list');
            
            if (connectBtn) {
                connectBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Connect button clicked');
                    connectToStream();
                });
            } else {
                console.error('Connect button not found!');
            }
            
            if (disconnectBtn) {
                disconnectBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    console.log('Disconnect button clicked');
                    disconnectStream();
                });
            }
            
            if (callIdInput) {
                callIdInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        console.log('Enter key pressed in input field');
                        connectToStream();
                    }
                });
            }
            
            // Event delegation for call list items (only add once)
            if (callListElement) {
                callListElement.addEventListener('click', (e) => {
                    const callItem = e.target.closest('.call-item');
                    if (callItem) {
                        const callId = callItem.getAttribute('data-call-id');
                        if (callId) {
                            console.log('Call item clicked:', callId);
                            connectToCall(callId);
                        }
                    }
                });
            }
        }
        
        // Initialize
        initializeEventListeners();
        loadCallHistory();
        setInterval(loadCallHistory, 5000); // Refresh every 5 seconds
    </script>
</body>
</html>

